# Clean Code, Clean Architecture & The Pragmatic Programmer - 规则总结

## Clean Code (Robert C. Martin)

### 命名规则
1. **名副其实** - 变量名应揭示意图，避免需要注释来解释
2. **避免误导** - 不用 accountList 除非真的是 List，不用保留字如 hp、aix
3. **做有意义的区分** - 避免 a1、a2，或 productInfo/productData 这种无意义的区分
4. **使用读得出来的名称** - 避免缩写如 genymdhms
5. **使用可搜索的名称** - 单字母名称只应在短作用域内使用
6. **避免使用编码** - 不用 m_ 前缀或匈牙利命名法
7. **类名用名词，方法名用动词** - 如 Customer、postPayment

### 函数规则
8. **短小** - 函数应该短小，20行封顶为佳
9. **只做一件事** - 函数应该只做一件事，做好这件事
10. **每个函数一个抽象层级** - 避免高层和底层代码混杂
11. **switch 语句** - 用多态替代，埋藏在较低的抽象层级
12. **使用描述性的名称** - 长而描述性的名字比短而费解的名字好
13. **函数参数** - 最理想是零个，其次一个，再次两个，尽量避免三个
14. **无副作用** - 函数承诺做一件事，但还做其他隐藏的事是危险的
15. **分隔指令与询问** - 要么做某事，要么回答某事，不要同时做
16. **使用异常替代返回错误码** - 错误处理代码与正常流程分离
17. **DRY - 不要重复自己** - 重复是软件中一切邪恶的根源

### 注释规则
18. **注释不能美化糟糕的代码** - 与其花时间写注释解释，不如花时间清理代码
19. **用代码来阐述** - 清晰的代码本身就是最好的文档
20. **好注释** - 法律信息、对意图的解释、警示、TODO
21. **坏注释** - 喃喃自语、多余的注释、误导性注释、日志式注释、废话注释

### 格式规则
22. **垂直格式** - 源文件像报纸文章，从上到下可读性递增
23. **概念相关代码应该放在一起** - 相关性强的代码应该垂直靠近
24. **垂直顺序** - 被调用的函数应该放在执行调用的函数下面
25. **水平格式** - 一行代码不要太长，80-120字符为宜
26. **水平对齐** - 不要刻意对齐，除非能显著增强可读性
27. **缩进** - 用缩进体现层级结构

### 对象和数据结构规则
28. **数据抽象** - 隐藏实现，暴露抽象接口
29. **得墨忒耳法则** - 模块不应了解它所操作对象的内部情形
30. **数据传送对象** - DTO 是只有公共变量、没有函数的类

### 错误处理规则
31. **使用异常而非返回码** - 错误处理与主逻辑分离
32. **先写 Try-Catch-Finally 语句** - 定义用户应该得到什么样的范围
33. **使用不可控异常** - 可控异常违反开闭原则
34. **给出异常发生的环境说明** - 包含足够的信息定位问题
35. **依调用者需要定义异常类** - 对错误分类的方式很重要
36. **别返回 null 值** - 返回空列表或特殊对象
37. **别传递 null 值** - 禁止传入 null 是合理的

### 边界规则
38. **学习第三方代码** - 编写学习性测试，了解第三方 API
39. **使用尚不存在的代码** - 定义自己的接口，适配第三方代码
40. **整洁的边界** - 边界上需要清晰的分隔和测试

### 类规则
41. **类的组织** - 公共静态常量 → 私有静态变量 → 私有实体变量 → 公共函数 → 私有工具函数
42. **类应该短小** - 类的名称应该描述其权责，无法命名说明太庞大
43. **单一权责原则 (SRP)** - 类或模块应有且只有一条加以修改的理由
44. **内聚** - 类应该只有少量实体变量，每个方法都操作一个或多个变量
45. **为了修改而组织** - 隔离修改，使用抽象和接口

---

## Clean Architecture (Robert C. Martin)

### 设计原则 (SOLID)

#### 单一职责原则 (SRP)
46. **一个模块应该只对一类行为者负责** - 不同的行为者不应该耦合在一起

#### 开闭原则 (OCP)
47. **对扩展开放，对修改关闭** - 通过抽象和接口，新功能通过添加代码而非修改现有代码实现

#### 里氏替换原则 (LSP)
48. **子类型必须能够替换其基类型** - 继承必须确保派生类的行为符合基类的契约

#### 接口隔离原则 (ISP)
49. **不应强迫客户依赖它们不用的方法** - 将胖接口拆分为多个小接口

#### 依赖反转原则 (DIP)
50. **高层模块不应依赖低层模块，两者都应依赖抽象** - 抽象不应依赖细节，细节应依赖抽象

### 组件构建原则

#### 组件内聚原则
51. **重用/发布等价原则 (REP)** - 重用的粒度就是发布的粒度
52. **共同闭包原则 (CCP)** - 同时修改的类应该放在一起
53. **共同重用原则 (CRP)** - 不一起重用的类不应该放在一起

#### 组件耦合原则
54. **无环依赖原则 (ADP)** - 组件依赖图中不应该出现环
55. **稳定依赖原则 (SDP)** - 依赖应该指向更稳定的方向
56. **稳定抽象原则 (SAP)** - 组件的抽象程度应该与其稳定程度一致

### 架构规则
57. **独立于框架** - 架构不应依赖于框架的具体功能
58. **可测试性** - 业务规则可以在没有 UI、数据库、Web 服务器等外部元素的情况下测试
59. **独立于 UI** - 可以在不更改业务规则的情况下轻松更改 UI
60. **独立于数据库** - 业务规则不绑定于特定的数据库
61. **独立于任何外部机构** - 业务规则不依赖于外部世界的变化

### 整洁架构层次
62. **实体层 (Entities)** - 封装企业级的业务规则，最抽象、最稳定
63. **用例层 (Use Cases)** - 包含应用特定的业务规则，编排数据流向实体层
64. **接口适配器层 (Interface Adapters)** - 将数据转换为用例层和实体层需要的格式
65. **框架与驱动层 (Frameworks & Drivers)** - 最外层，包含框架和工具
66. **依赖规则** - 内层不依赖外层，依赖只能向内指向

---

## The Pragmatic Programmer (Andrew Hunt & David Thomas)

### 哲学规则
67. **关心你的技艺** - 如果你不在乎能否漂亮地开发出软件，你又为何要开发软件呢？
68. **思考！你的工作** - 关掉自动驾驶仪，接管操作，不断批评和改进你的工作
69. **提供多种选择，不要找蹩脚的借口** - 提供选择，而不是找借口
70. **不要容忍破窗户** - 看到糟糕的设计、错误的决策、低劣的代码，立即修复
71. **做变化的催化剂** - 你不能强迫人们改变，但可以展示未来可能的样子
72. **记住大图景** - 不要只专注于细节，而忽视了周围正在发生的事情
73. **使质量成为需求问题** - 让用户决定系统的质量属性

### 学习方法
74. **投资你的知识资产** - 定期学习新东西，多样化、管理风险、低买高卖、重新评估平衡
75. **批判性地分析你读到的和听到的** - 不要被供应商、媒体炒作、教条所左右
76. **英语是编程语言** - 把你的想法写下来，写作即思考
77. **知道你想说什么** - 规划你要说的内容，简洁明了
78. **了解你的听众** - 只有当你传达的信息被理解时，沟通才算成功
79. **选择时机** - 了解你的听众何时需要听
80. **让文档美观** - 格式很重要，花时间让文档看起来不错
81. **让听众参与** - 尽早获得反馈，让听众参与文档的编写

### 编程规则
82. **DRY - 不要重复自己** - 系统中的每一项知识都必须具有单一、无歧义、权威的表示
83. **正交性** - 消除无关事物之间的影响，提高生产力和降低风险
84. **可逆性** - 没有什么最终决定，保持选择的开放性
85. **曳光弹** - 在黑暗中发射曳光弹，找到目标，然后调整
86. **原型与便签** - 为了学习而制作原型，然后扔掉它
87. **领域语言** - 使用问题领域的语言编程
88. **估算** - 学会估算，避免给出没有准备的承诺

### 工具规则
89. **纯文本的力量** - 纯文本不会过时，易于测试、解析、理解
90. **利用命令 shell 的力量** - 学习使用 shell，它是你的工具箱
91. **用好一种编辑器** - 精通一种编辑器，知道它的所有快捷键
92. **总是使用版本控制** - 即使是一个人项目也要用版本控制
93. **修复问题，而不是归咎** - bug 是你的错还是别人的错并不重要，它仍然是你的问题

### 编码规则
94. **按合约设计** - 使用前置条件、后置条件、不变量
95. **死程序不说谎** - 尽早崩溃，崩溃通常是你的最佳选择
96. **断言式编程** - 如果它不可能发生，用断言确保它不会发生
97. **何时使用异常** - 将异常用于异常的问题
98. **怎样配平资源** - 有始有终，分配资源的例程也应该释放它
99. **不要冲出前灯范围** - 小步前进，由反馈驱动
100. **避免巧合编程** - 不要依赖巧合，要理解你编写的代码
101. **估算你的算法的阶** - 了解 O() 表示法，估算算法复杂度
102. **测试你的估算** - 数学分析只能到此为止，测量真实世界的性能

### 项目规则
103. **解耦与得墨忒耳法则** - 减少模块之间的耦合
104. **元程序设计** - 将抽象放入代码，细节放入元数据
105. **时间耦合** - 分析工作流中的并发性，提高灵活性和吞吐量
106. **它只是视图** - 使视图与模型分离
107. **黑板** - 使用黑板协调工作流
108. **不要靠巧合编程** - 依靠可靠的事物，不要依靠假设
109. **估算算法阶** - 在开始编程前估算资源消耗
110. **重构** - 尽早重构，经常重构，像外科医生一样：先让代码可测试
111. **易于测试的代码** - 设计时就考虑测试，使模块易于测试
112. **邪恶的向导** - 不要使用你不理解的向导代码

### 需求规则
113. **不要收集需求——挖掘它们** - 需求很少存在于表面，需要深入挖掘
114. **与用户一同工作** - 用户比你更了解他们的工作
115. **抽象比细节活得更久** - 为抽象而设计，为变化而规划
116. **使用项目词汇表** - 创建并维护项目词汇表

### 团队规则
117. **不要跳出同样的坑** - 从错误中学习，团队也需要这样做
118. **团队的知识** - 维护团队的知识资产
119. **交流！** - 与团队沟通，分享知识

### 自动化规则
120. **无情的测试** - 测试早期，测试经常，测试自动
121. **编码不停，测试不止** - 单元测试、集成测试、验证和校验、资源耗尽、错误和恢复、性能测试、可用性测试
122. **全部都要测试** - 测试覆盖所有代码路径
123. **通过代码查找 bug** - 使用调试器，但不要迷信它
124. **修正问题，而不是发出警告** - 消除警告，而不是隐藏它们

### 安全规则
125. **通过合约设计** - 使用合约建立软件的行为边界
126. **断言式编程** - 如果它不可能发生，用断言确保它不会发生
127. **何时使用异常** - 异常应该用于异常的情况
128. **怎样配平资源** - 分配资源的代码应该负责释放它

---

## 核心交叉规则

这三本书反复强调的关键原则：

| 主题 | 核心规则 |
|------|----------|
| **命名** | 清晰、有意义、可搜索 |
| **函数/方法** | 短小、单一职责、低参数 |
| **DRY** | 知识只应存在一处 |
| **测试** | 自动化、早期、经常 |
| **抽象** | 依赖抽象，而非具体 |
| **耦合** | 低耦合、高内聚 |
| **错误处理** | 用异常而非错误码 |
| **注释** | 代码自解释优于注释 |
| **重构** | 持续改进，不留破窗户 |
| **学习** | 持续投资知识资产 |

---

*总结日期: 2026-02-18*
